# åˆå¹¶å¤„ç†åŒä¸€æ¥å£çš„å¹¶å‘è¯·æ±‚
> åœºæ™¯: 
  æ¥å£æ˜¯æ”¯æŒ [id1,id2,id3]è¿™ç§å½¢å¼æ‰¹é‡è·å–æ•°æ®çš„ã€‚
  æ¯ä¸ª webview ä» render è°ƒç”¨æ–¹æ³•è·å–æ•°æ®ï¼Œå¦‚æœ webview å¤šäº†å¯èƒ½ä¼šæœ‰å¤§çš„å¹¶å‘è¯·æ±‚ï¼Œæ‰€ä»¥å¯èƒ½ç­‰ 50 ms, æ”¶é›†æ‰€æœ‰è¯·æ±‚å‚æ•°ï¼Œç„¶åå‘ä¸€ä¸ªè¯·æ±‚å°±å¥½ã€‚
```javascript
export function createDebouncedBatcher<TId extends string, TResult, TItem = TResult>(
  fetcher: (ids: TId[]) => Promise<TResult>,
  options: DebouncedBatcherOptions<TId, TResult, TItem> = {}
): DebouncedBatcher<TId, TResult, TItem> {
  const defer = options.defer ?? 50;
  const pickById = options.pickById;

  let timer: ReturnType<typeof setTimeout> | null = null;
  let pendingIds = new Set<TId>();
  let waitersById = new Map<TId, Array<DebouncedBatcherDeferred<TItem>>>();
  let flushing = false;

  const cancelTimer = () => {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };

  const scheduleFlush = (flushFn: () => void) => {
    if (timer) return;
    timer = setTimeout(() => {
      timer = null;
      flushFn();
    }, defer);
  };

  const flush = async (): Promise<void> => {
    if (flushing) return;
    if (pendingIds.size === 0) return;

    flushing = true;

    // å¿«ç…§å¹¶æ¸…ç©ºï¼ˆæ–° enqueue è¿›å…¥ä¸‹ä¸€æ‰¹ï¼‰
    const ids = Array.from(pendingIds);
    const localWaiters = waitersById;

    pendingIds = new Set<TId>();
    waitersById = new Map<TId, Array<DebouncedBatcherDeferred<TItem>>>();

    try {
      const result = await fetcher(ids);

      // å°†åŒä¸€æ‰¹æ¬¡ result åˆ†å‘ç»™æ¯ä¸ª id çš„æ‰€æœ‰ waiter
      for (const id of ids) {
        const waiters = localWaiters.get(id);
        if (!waiters || waiters.length === 0) continue;
        const picked = pickById ? pickById(result, id) : (result as unknown as TItem);
        waiters.forEach(({ resolve }) => resolve(picked));
      }
    } catch (error) {
      for (const id of ids) {
        const waiters = localWaiters.get(id);
        if (!waiters || waiters.length === 0) continue;
        waiters.forEach(({ reject }) => reject(error));
      }
    } finally {
      flushing = false;

      // å¦‚æœ flush è¿‡ç¨‹ä¸­æœ‰æ–° pendingï¼Œå°½å¿«å®‰æ’ä¸‹ä¸€è½®ï¼ˆä¸å†ç­‰å¾… deferï¼‰
      if (pendingIds.size > 0 && !timer) {
        timer = setTimeout(() => {
          timer = null;
          void flush();
        }, 0);
      }
    }
  };

  const enqueue = (id: TId): Promise<TItem> => {
    pendingIds.add(id);

    const promise = new Promise<TItem>((resolve, reject) => {
      const list = waitersById.get(id) ?? [];
      list.push({ resolve, reject });
      waitersById.set(id, list);
    });

    scheduleFlush(() => {
      void flush();
    });

    return promise;
  };

  const flushNow = async (): Promise<void> => {
    cancelTimer();
    await flush();
  };

  return {
    enqueue,
    flushNow,
    cancelTimer,
    getPendingCount: () => pendingIds.size,
    isFlushing: () => flushing,
  };
}

```

# Promise.withResolves

è¿™ä¸ªå¾ˆå·§å¦™ï¼Œå’Œæ— æ„Ÿåˆ·æ–°tokenä¸€æ ·ï¼Œä¿å­˜äº† resolveã€‚åœ¨éœ€è¦çš„æ—¶å€™è°ƒç”¨ï¼Œå°¤å…¶åœ¨åˆ¤æ–­ä»€ä¹ˆä¸œè¥¿æ˜¯å¦å‡†å¤‡å¥½äº†çš„åœºæ™¯å¾ˆå¥½ç”¨ã€‚

``` javascript
function withResolves(){
	let done, fail;
	const run = new Promise((resolve, reject) => {
		done = resolve;
		fail = reject;
	})
	return {done, fail, run};
}


// å¯ä»¥åˆ†åˆ«åœ¨ä¸åŒçš„åœ°æ–¹ä½¿ç”¨ done

// A é¡µé¢å‘ç°å·²ç»æ»¡è¶³æ¡ä»¶å°± done()
// B é¡µé¢ await run(), å¦‚æœå®Œæˆäº†å°±ç»§ç»­æ‰§è¡Œï¼Œæ²¡å®Œæˆå°±ç­‰å¾…
```
ä¹Ÿå¯ä»¥ç”¨ä¸‹é¢çš„ **Signal** è§£å†³
# Signal


```javascript
import { useEffect } from 'react';

function Dashboard() {
  useEffect(() => {
    // 1. åˆ›å»ºå”¯ä¸€çš„æ§åˆ¶å™¨ (ç«è­¦æŒ‰é’®)
    const controller = new AbortController();
    const signal = controller.signal; // è­¦æŠ¥ä¿¡å·

    console.log("ç»„ä»¶æŒ‚è½½ï¼Œä»»åŠ¡å¼€å§‹...");

    // --- ä»»åŠ¡ A: Fetch (åŸç”Ÿæ”¯æŒ signal) ---
    fetch('/api/history-data', { signal })
      .then(res => res.json())
      .catch(err => {
        if (err.name === 'AbortError') console.log('Fetch è¢«è‡ªåŠ¨å–æ¶ˆäº†');
      });

    // --- ä»»åŠ¡ B: WebSocket (éœ€è¦æ‰‹åŠ¨ç›‘å¬) ---
    const socket = new WebSocket('ws://data-stream.com');
    // ç›‘å¬ signal çš„ abort äº‹ä»¶
    signal.addEventListener('abort', () => {
      console.log('æ”¶åˆ°ä¿¡å·ï¼Œå…³é—­ Socket');
      socket.close(); // æ‰‹åŠ¨å…³é—­
    });

    // --- ä»»åŠ¡ C: å¤æ‚çš„ Canvas åŠ¨ç”» (éœ€è¦æ‰‹åŠ¨ç›‘å¬) ---
    let animationId;
    const animate = () => {
      // æ¯ä¸€å¸§éƒ½æ£€æŸ¥ä¸€ä¸‹ï¼šæ˜¯ä¸æ˜¯è¯¥åœäº†ï¼Ÿ
      if (signal.aborted) return; 
      
      // ç”»ç”»é€»è¾‘...
      animationId = requestAnimationFrame(animate);
    };
    animate();


    // 2. ç»„ä»¶é”€æ¯æ—¶ (Cleanup Function)
    return () => {
      console.log("ç”¨æˆ·åˆ‡èµ°äº†ï¼ŒæŒ‰ä¸‹ç«è­¦æŒ‰é’®ï¼");
      // âš¡ï¸ æ ¸å¿ƒï¼šä¸€é”®è§¦å‘æ‰€æœ‰ä»»åŠ¡çš„åœæ­¢é€»è¾‘
      controller.abort(); 
    };
  }, []);

  return <div>ç›‘æ§å¤§å±</div>;
}
```

# æƒ°æ€§å•ä¾‹

**åœºæ™¯ï¼š** ä½ æœ‰ä¸€ä¸ªå¾ˆé‡çš„ SDKï¼ˆæ¯”å¦‚åœ°å›¾ã€IMã€æ”¯ä»˜ï¼‰ï¼Œæˆ–è€…ä¸€ä¸ªå¾ˆè´µçš„è®¡ç®—ã€‚ä½ ä¸æƒ³é¡µé¢ä¸€åŠ è½½å°±åˆå§‹åŒ–ï¼Œè€Œæƒ³ç­‰åˆ°**ç¬¬ä¸€æ¬¡æœ‰äººè°ƒç”¨å®ƒ**æ—¶å†åˆå§‹åŒ–ï¼Œä¸”åªåˆå§‹åŒ–ä¸€æ¬¡ã€‚ **æ™®é€šåšæ³•ï¼š** å…¨å±€å˜é‡ `let instance = null`ï¼Œæ¯æ¬¡ç”¨çš„æ—¶å€™ `if (!instance) init()`ã€‚æœ‰ç‚¹å•°å—¦ã€‚ **é«˜çº§æŠ€å·§ï¼š** **é‡å†™è‡ªèº«å‡½æ•° (Function Overwriting)ã€‚**

```JavaScript
let getHeavySDK = async () => {
    console.log('ğŸš§ ç¬¬ä¸€æ¬¡è°ƒç”¨ï¼šæ­£åœ¨åˆå§‹åŒ–...');
    
    // 1. æ‰§è¡Œåˆå§‹åŒ–
    const sdk = await import('./heavy-sdk'); 
    const instance = sdk.createInstance();

    // 2. ã€æ ¸å¿ƒæŠ€å·§ã€‘é‡å†™å‡½æ•°æœ¬èº«ï¼
    // ä¸‹æ¬¡å†è°ƒç”¨ getHeavySDKï¼Œç›´æ¥æ‰§è¡Œä¸‹é¢è¿™ä¸ªå‡½æ•°ï¼Œä¸å†èµ°ä¸Šé¢çš„é€»è¾‘
    getHeavySDK = async () => {
        console.log('ğŸš€ åç»­è°ƒç”¨ï¼šç›´æ¥è¿”å›å®ä¾‹');
        return instance;
    };

    return instance;
};

// --- ä½¿ç”¨åœºæ™¯ ---
await getHeavySDK(); // æ‰“å°ï¼šğŸš§ ç¬¬ä¸€æ¬¡è°ƒç”¨...
await getHeavySDK(); // æ‰“å°ï¼šğŸš€ åç»­è°ƒç”¨... (è¿ if åˆ¤æ–­éƒ½çœäº†)
```

**åŸç†ï¼š** è¿™æ˜¯ä¸€ä¸ªæå…¶çº¯ç²¹çš„æ€§èƒ½ä¼˜åŒ–ï¼Œåˆ©ç”¨ JS å‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘çš„ç‰¹æ€§ï¼Œåœ¨è¿è¡Œæ—¶åŠ¨æ€ä¿®æ”¹å‡½æ•°çš„å®šä¹‰ã€‚

# tapable

```html
 <script>
      class AsyncSeriesWaterfallHook {
        constructor(args = []) {
          this._args = args; // ç¤ºä¾‹: ["source", "config"]
          this.taps = [];
        }

        // æ³¨å†Œå¼‚æ­¥å›è°ƒæ’ä»¶
        tapAsync(name, fn) {
          this.taps.push(fn);
        }

        compile() {
          const params = this._args.join(", "); // "source, config"
          const firstArg = this._args[0]; // "source"

          // åŠ¨æ€ç”Ÿæˆæ‰§è¡Œé€»è¾‘
          // æ ¸å¿ƒæ€æƒ³ï¼šæ‰‹åŠ¨æ„å»ºä¸€ä¸ªé€’å½’å‡½æ•° next(i, currentSource)
          let code = `
          var taps = _x;
          var index = 0;

          function next(err, newValue) {
            if (err) return finalCallback(err);
            if (newValue !== undefined) {
              ${firstArg} = newValue; // æ›´æ–°æµæ°´çº¿çš„å€¼
            }

            if (index >= taps.length) {
              return finalCallback(null, ${firstArg});
            }

            var tapFn = taps[index++];
            // è°ƒç”¨æ’ä»¶ï¼Œæœ€åå¢åŠ ä¸€ä¸ª next å›è°ƒ
            tapFn(${params}, next);
          }

          next(null, ${firstArg});
        `;

          // ç”Ÿæˆå‡½æ•°ï¼šæœ€åä¸€ä¸ªå‚æ•°æ°¸è¿œæ˜¯ callback
          return new Function("_x", ...this._args, "finalCallback", code);
        }

        callAsync(...args) {
          const finalCallback = args.pop(); // æœ€åä¸€ä¸ªæ˜¯å›è°ƒå‡½æ•°
          if (!this._callAsync) {
            this._callAsync = this.compile();
          }
          // ä¼ å…¥æ’ä»¶æ•°ç»„ã€ç”¨æˆ·å‚æ•°ã€ä»¥åŠæœ€ç»ˆå›è°ƒ
          this._callAsync(this.taps, ...args, finalCallback);
        }
      }

      // --- ç”Ÿäº§ç¯å¢ƒæµ‹è¯•ä»£ç  ---

      const pipeline = new AsyncSeriesWaterfallHook(["source", "config"]);

      // æ’ä»¶ A: æ¨¡æ‹Ÿå¼‚æ­¥ Babel è½¬æ¢
      pipeline.tapAsync("Babel", (source, config, next) => {
        console.log(">>> æ­£åœ¨æ‰§è¡Œ Babel...");
        setTimeout(() => {
          const newSource = source + ` /* mode: ${config.mode} */`;
          next(null, newSource);
        }, 500);
      });

      // æ’ä»¶ B: æ¨¡æ‹Ÿå¼‚æ­¥ Uglify æ··æ·†
      pipeline.tapAsync("Uglify", (source, config, next) => {
        console.log(">>> æ­£åœ¨æ‰§è¡Œ Uglify...");
        setTimeout(() => {
          // æ­¤æ—¶ source å·²ç»æ˜¯ Babel å¤„ç†è¿‡çš„äº†
          const newSource = source + " + Minified";
          next(null, newSource);
        }, 500);
      });

      // æ‰§è¡Œ
      console.time("cost");
      pipeline.callAsync("const a = 1;", { mode: "production" }, (err, result) => {
        if (err) console.error(err);
        console.log("æœ€ç»ˆäº§ç‰©:", result);
        console.timeEnd("cost"); // é¢„æœŸè€—æ—¶ 1s å·¦å³
      });
    </script>
```

```js
// å¼•å…¥æˆ‘ä»¬ä¹‹å‰å®ç°çš„ Hook ç±»ï¼ˆè¿™é‡Œç®€åŒ–å±•ç¤ºï¼‰
class MiniBundler {
  constructor() {
    this.hooks = {
      // 1. å¯»æ‰¾å…¥å£ï¼šåŒæ­¥é’©å­
      beforeRun: new SyncHook(["compilerName"]),
      
      // 2. è½¬æ¢ä»£ç ï¼šå¼‚æ­¥æµæ°´çº¿ï¼ˆç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä»£ç ï¼Œç¬¬äºŒä¸ªæ˜¯é…ç½®ï¼‰
      transform: new AsyncSeriesWaterfallHook(["source", "options"]),
      
      // 3. è¾“å‡ºæ–‡ä»¶ï¼šå¼‚æ­¥å¹¶è¡Œï¼ˆå¤šä¸ªä»»åŠ¡åŒæ—¶è·‘ï¼Œå…¨å®Œäº‹æ‰ç»“æŸï¼‰
      emit: new AsyncParallelHook(["assets"])
    };
  }

  async run(entryCode) {
    console.log("=== å¯åŠ¨ç¼–è¯‘æµç¨‹ ===\n");

    // é˜¶æ®µ 1: beforeRun
    this.hooks.beforeRun.call("MyBundler");

    // é˜¶æ®µ 2: transform (æµæ°´çº¿åŠ å·¥)
    // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦æ”¯æŒå¼‚æ­¥
    const transformedCode = await this.hooks.transform.promise(entryCode, { minify: true });
    
    // é˜¶æ®µ 3: emit (å¹¶è¡Œåˆ†å‘)
    const assets = { "bundle.js": transformedCode };
    await this.hooks.emit.promise(assets);

    console.log("\n=== ç¼–è¯‘æˆåŠŸ ===");
  }
}


const bundler = new MiniBundler();

// æ’ä»¶ 1: æ—¥å¿—æ’ä»¶
bundler.hooks.beforeRun.tap("LogPlugin", (name) => {
  console.log(`[Log] æ­£åœ¨åˆå§‹åŒ–ç¼–è¯‘å™¨: ${name}`);
});

// æ’ä»¶ 2: Babel è½¬æ¢æ’ä»¶ï¼ˆæ¨¡æ‹Ÿå¼‚æ­¥ï¼‰
bundler.hooks.transform.tapPromise("BabelPlugin", (source, options) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("[Transform] Babel è½¬æ¢ä¸­...");
      resolve(`${source} -> (ES5)`);
    }, 500);
  });
});

// æ’ä»¶ 3: æ³¨å…¥ Banner æ’ä»¶ï¼ˆåœ¨ Babel ä¹‹åæ‰§è¡Œï¼Œå› ä¸ºæ˜¯é¡ºåºæ³¨å†Œï¼‰
bundler.hooks.transform.tapPromise("BannerPlugin", (source) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("[Transform] æ³¨å…¥ç‰ˆæƒå£°æ˜...");
      resolve(`/** (c) 2026 Gemini **/ \n${source}`);
    }, 300);
  });
});

// æ’ä»¶ 4: æœ¬åœ°è¾“å‡ºæ’ä»¶ï¼ˆå¹¶è¡Œä»»åŠ¡ 1ï¼‰
bundler.hooks.emit.tapPromise("FileSystemPlugin", (assets) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("[Emit] å·²å†™å…¥ç£ç›˜æ–‡ä»¶: ", Object.keys(assets));
      resolve();
    }, 400);
  });
});

// æ’ä»¶ 5: CDN ä¸Šä¼ æ’ä»¶ï¼ˆå¹¶è¡Œä»»åŠ¡ 2ï¼‰
bundler.hooks.emit.tapPromise("CloudPlugin", (assets) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("[Emit] å·²åŒæ­¥è‡³ AWS S3...");
      resolve();
    }, 600);
  });
});

// --- æ‰§è¡Œæ‰“åŒ… ---
bundler.run("const a = 1;");
```